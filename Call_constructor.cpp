/*
复制控制（复制构造函数、赋值操作符、析构函数）的调用时机测试(一)
*/
class A {
	int data;
public:
	A() {
		cout << "\tA()" << endl;
	}

	A(const A & a) {
		data = a.data;
		cout << "\t复制构造函数" << endl;
	}

	A& operator=(const A& rhs) {
		cout << "\toperator=" << endl;
		return *this;
	}
};

A global;                     //调用构造函数

A foo(A arg) { 
	//调用复制构造函数，用arg初始化局部对象local
	cout << "2---------------" << endl;
	A local = arg;

	//这里是复制初始化方式：先调用指定构造函数创建临时对象，然后
	//用复制构造函数将临时对象复制到正在创建的对象。
	//但是编译器一般会优化，直接跳过复制构造函数直接创建对象，
	//所以这里并没有调用复制构造函数
	cout << "3---------------" << endl;
	A local2 = A();
	cout << "4---------------" << endl;

	//下面两句均调用复制构造函数
	A local3 = arg;
	A local4 = A(arg);
	local4 = arg;          //使用赋值操作符
	cout << "41--------------" << endl;
	A *heap = new A(global); //调用复制构造函数，根据全局对象global创建新的A对象
	cout << "5---------------" << endl;

	//这句没有调用(复制)构造函数,使用赋值操作符
	*heap = local;           
	cout << "6---------------" << endl;

	// 这里两次调用复制构造函数、两次调用默认构造函数
	// 如果没有为类类型数组提供元素初始化式，则将用默认构造函数初始化每个元素；
	// 如果使用常规的花括号括住数组初始化列表（如下）来显示初始化，则使用复制
	// 初始化来初始化每个元素。根据指定的值创建适当类型的元素，然后用复制构造函数
	// 将该值复制到相应元素。如下的数组使用花括号，因此使用复制构造函数来初始化。
    A pa[4] = {local, *heap};
	cout << "7---------------" << endl;

    /*
    如果是这样的定义，则只调用四次构造函数，不会调用复制构造函数
    A pa[4];   
	*/

	return *heap;            //调用复制构造函数，从函数返回A对象*heap的副本
}

int main() {
	cout << "A aa: "; 
	A aa;        //调用构造函数
	foo(aa);     //调用复制构造函数，复制一个对象，将其作为实参传递给一个函数

	cout << endl << "8----------------" << endl;

	//使用了五次默认构造函数和复制构造函数，先使用A的默认构造函数创建临时值
	//来初始化avec，然后使用复制构造函数将临时值复制到avec的每个元素。
	vector<A> avec(5);  
	return 0;
}
